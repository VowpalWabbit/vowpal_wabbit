# pyproject.toml file for building Vowpal Wabbit python wheels

[build-system]
requires = [
    "setuptools",
    "wheel",
    "cmake",
    "ninja",
]
build-backend = "setuptools.build_meta"

[tool.cibuildwheel]
build = ["cp310-*", "cp311-*", "cp312-*", "cp313-*"]  # Python 3.10-3.13 (3.14 skipped due to Boost.Python incompatibility)
skip = [
    "*musllinux*",  # Only build manylinux wheels
]
# Skip ARM64 tests: Even with conservative build flags (-mno-outline-atomics, -march=armv8-a),
# tests fail with illegal instruction. Root cause: System Boost libraries from dnf contain
# LSE atomics and SVE instructions compiled for newer ARM CPUs. Wheels build successfully with
# baseline ARMv8.0 flags and should work on all ARM64 systems.
test-skip = "*-manylinux_aarch64"
test-requires = ["pytest", "pyclean", "vw-executor", "setuptools", "scipy", "scikit-learn"]
test-command = [
    "pyclean {project}/python/tests",
    "pytest {project}/python/tests",
]
test-sources = "test/"

[tool.cibuildwheel.linux]
before-all = [
    # Install build tools and boost development packages
    # cibuildwheel runs in Red Hat based Linux container environment (AlmaLinux 8)
    "dnf install -y cmake ninja-build boost-devel boost-python3-devel boost-static zlib-devel",
]
before-build = [
    # Container uses an old version of Boost Python incompatible with Python 3.11+ C API
    # Depending on Python version, apply patch to make_instance.hpp
    "dnf reinstall -y boost-devel",
    "if [ $(python -c 'import sys; print(sys.version_info.minor)') -ge 11 ]; then patch /usr/include/boost/python/object/make_instance.hpp /project/python/boost_python_make_instance.patch; fi",
    # Python 3.13+ uses PyObject_CallFunction instead of PyEval_CallFunction etc.
    "if [ $(python -c 'import sys; print(sys.version_info.minor)') -ge 13 ]; then sed -i 's/PyEval_Call/PyObject_Call/g' /usr/include/boost/python/*.hpp; fi",
    # Force CMake to use FindBoost MODULE mode instead of CONFIG mode
    # The manylinux container's Boost doesn't provide BoostConfig.cmake files
    "sed -i 's/cmake_policy(SET CMP0167 NEW)/cmake_policy(SET CMP0167 OLD)/' /project/CMakeLists.txt",
]
# Use vendored zlib (VW_ZLIB_SYS_DEP=OFF) for self-contained wheels that auditwheel can properly tag
# Enable SIMD optimizations (VW_FEAT_LAS_SIMD=ON) for x64 builds - disabled for ARM64 in override below
environment = { BOOST_PY_VERSION_SUFFIX="3", CMAKE_ARGS="-DBoost_NO_BOOST_CMAKE=ON -DVW_ZLIB_SYS_DEP=OFF -DVW_FEAT_LAS_SIMD=ON" }

[tool.cibuildwheel.macos]
before-all = [
    # Install build tools and boost-python via Homebrew
    "brew install cmake ninja boost-python3",
    # Test if simple extension can avoid NOUNDEFS
    "cd test_extension && ./test_build.sh && cd ..",
    # Test if delocate-wheel breaks working extensions
    "cd test_extension && ./test_wheel.sh && cd ..",
]
test-command = [
    # vw_test_module is now tested immediately after build in CMakeLists.txt
    # Diagnostic: Find and inspect pylibvw.so WITHOUT importing it
    "python -c 'import subprocess, glob, sysconfig, sys; sp = sysconfig.get_path(\"platlib\"); pattern = sp + \"/pylibvw*.so\"; files = glob.glob(pattern); so = files[0] if files else None; print(f\"=== Found: {so} ===\"); subprocess.run([\"otool\", \"-L\", so], check=True) if so else None; print(\"\\n=== Mach-O header ===\"); subprocess.run([\"otool\", \"-hv\", so], check=True) if so else None; print(\"\\n=== Undefined symbols (first 30) ===\"); subprocess.run([\"sh\", \"-c\", f\"nm -u {so} | head -30\"], check=True) if so else None; print(\"\\n=== Python executable info ===\"); subprocess.run([\"otool\", \"-hv\", sys.executable], check=True); print(\"\\n=== Trying to import pylibvw ===\"); exec(\"import pylibvw; print(\\\"SUCCESS: pylibvw imported!\\\")\")' || true",
    # Run actual tests
    "pyclean {project}/python/tests",
    "pytest {project}/python/tests",
]
# Homebrew's Boost requires macOS 14.0+
environment = { MACOSX_DEPLOYMENT_TARGET="14.0", DISABLE_VCPKG="1", BOOST_PY_VERSION_SUFFIX="3", CMAKE_ARGS="-DBoost_NO_BOOST_CMAKE=OFF -DCMAKE_POLICY_DEFAULT_CMP0167=NEW -DCMAKE_PREFIX_PATH=/opt/homebrew;/usr/local -DCMAKE_VERBOSE_MAKEFILE=ON" }
repair-wheel-command = "delocate-wheel --require-archs {delocate_archs} -w {dest_dir} -v {wheel} --ignore-missing-dependencies"

[tool.cibuildwheel.windows]
before-all = [
    # Initialize vcpkg submodule and update to get latest ports
    "git submodule update --init --recursive ext_libs\\vcpkg && cd ext_libs\\vcpkg && git pull origin master && cd ..\\..",
    # Install boost-python with x64-windows triplet
    "cd ext_libs\\vcpkg && .\\bootstrap-vcpkg.bat && .\\vcpkg install boost-python:x64-windows zlib:x64-windows --classic --no-print-usage",
]
environment = { BOOST_PY_VERSION_SUFFIX="3" }

# Override for ARM64 Linux builds to use conservative architecture flags
# -mno-outline-atomics: Prevents GCC from using LSE atomic instructions (ARMv8.1+) which cause illegal instruction on older CPUs
# -march=armv8-a: Baseline ARMv8.0 instruction set only (NEON is part of baseline and safe to use)
# -mtune=generic: Don't optimize for specific CPU variant
[[tool.cibuildwheel.overrides]]
select = "*-manylinux_*_aarch64"
environment = { BOOST_PY_VERSION_SUFFIX="3", CMAKE_ARGS="-DBoost_NO_BOOST_CMAKE=ON -DVW_ZLIB_SYS_DEP=OFF -DVW_FEAT_LAS_SIMD=OFF -DCMAKE_CXX_FLAGS='-march=armv8-a -mtune=generic -mno-outline-atomics' -DCMAKE_C_FLAGS='-march=armv8-a -mtune=generic -mno-outline-atomics'" }
